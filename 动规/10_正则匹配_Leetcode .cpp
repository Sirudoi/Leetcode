class Solution {
public:
    bool isMatch(const char& s, const char& p) {
        if (p == '.' || s == p) return true;
        else return false;
    }

    bool isMatch(string s, string p) {
        // dp[i][j]表示, s的前i个字符能否于p的前j个字符匹配
        // -----------------------------------------------------------------------------
        // 情况一: p[j] == 小写字母
        // s[i] == p[j], 则有dp[i][j] = dp[i - 1][j - 1]
        // s[i] != p[j], 则有dp[i][j] = false
        // -----------------------------------------------------------------------------
        // 情况二: p[j] == '.'
        // 此时同情况一的s[i] == p[j]的逻辑, 因为'.'能匹配任意字符, 即s[i]和p[j]一定匹配
        // 此时, 则有dp[i][j] = dp[i - 1][j - 1]
        // -----------------------------------------------------------------------------
        // 情况三: p[j] == '*'
        // 此时可以匹配0个p[j - 1], 或者匹配1个p[j - 1], 或者不匹配
        // 1. 如果s[i] != p[j - 1], 则此时*匹配多少个p[j - 1]都无法匹配成功, 所以此时需要匹配0个p[j - 1]
        // 则有, dp[i][j] = dp[i][j - 2]
        // 2. 如果s[i] == p[j - 1], 则此时可以匹配1个p[j - 1]使得s[i] == p[j], 并且此时p[j]还能继续往后匹配
        // 则有, dp[i][j] = dp[i - 1][j] || dp[i][j - 2]
        // ####################################################################################
        // 解释一下, 例如 ...a[b] 和 ...b[*]匹配
        // 由于*可以匹配若干个b, 所以 ...a[b] 和 ...b[*] 是否匹配就可以转化成子问题 ...[a]b 和 ...b[*]是否匹配
        // 如果...[a]b 和 ...b[*]匹配, 则...a[b] 和 ...b[*]可以匹配
        // 对于这种情况, dp[i][j] = dp[i - 1][j]
        // 
        // 也可以同情况1, 不使用匹配, 即让*匹配0个p[j - 1]
        // 所以 ...a[b] 和 ...b[*] 是否匹配就可以转化成子问题 ...a[b] 和 ..[.]b*是否匹配, 直接丢弃b*
        // 此时dp[i][j] = dp[i][j - 2]
        // ####################################################################################

        int n = s.size();
        int m = p.size();
        // dp[i][j]表示s的前i个字符是否能和p的前j个字符匹配
        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));
        // 两个空串可以匹配
        dp[0][0] = true;
        
        // 初始化第0行, 需要排除 "" 和 "a*" 这种是匹配的
        for (int i = 1; i <= m; ++i) {
            if (p[i - 1] == '*') {
                dp[0][i] = dp[0][i - 2];
            }
            else {
                dp[0][i] = false;
            }
        }

        // 从第1行, 第1列开始递推, 第0行初始化过了, 第0列必为0
        for (int i = 1; i <= n; ++i) {
            for(int j = 1; j <= m; ++j) {
                // 这里j表示p的第j个字符, 所以取值需要j - 1
                if (p[j - 1] == '*') {
                    // 这里不担心越界, 因为题目保证了*前面一定有字符, 所以走到这里j一定 >= 2
                    if (isMatch(s[i - 1], p[j - 2])) {
                        dp[i][j] = (dp[i - 1][j] || dp[i][j - 2]);
                    }
                    else {
                        dp[i][j] = dp[i][j - 2];
                    }
                }
                else {
                    // s[i] == p[j] --> 转化为子问题dp[i - 1][j - 1]
                    // s[i] != p[j] --> false
                    dp[i][j] = isMatch(s[i - 1], p[j - 1]) ? dp[i - 1][j - 1] : false;
                }

            }
        }

        // auto test = [](const bool& b)->const char*{
        //     return b ? "true" : "false";
        // };

        // for (int i = 0; i <= n; ++i) {
        //     for (int j = 0; j <= m; ++j) {
        //         printf("[%d][%d]:[%s]\n", i, j, test(dp[i][j]));
        //     }
        // }

        return dp[n][m];
    }
};